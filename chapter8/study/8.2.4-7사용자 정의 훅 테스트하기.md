# 8장 좋은 리액트 코드 작성을 위한 환경 구축하기

- [8장 좋은 리액트 코드 작성을 위한 환경 구축하기](#8장-좋은-리액트-코드-작성을-위한-환경-구축하기)
  - [8.2 리액트 팀이 권장하는 리액트 테스트 라이브러리](#82-리액트-팀이-권장하는-리액트-테스트-라이브러리)
    - [8.2.4 사용자 정의 훅 테스트하기](#824-사용자-정의-훅-테스트하기)
    - [8.2.5 테스트를 작성하기에 앞서 고려해야 할 점](#825-테스트를-작성하기에-앞서-고려해야-할-점)
    - [8.2.6 그 밖에 해볼만한 여러 가지 테스트](#826-그-밖에-해볼만한-여러-가지-테스트)
    - [8.2.7 정리](#827-정리)

## 8.2 리액트 팀이 권장하는 리액트 테스트 라이브러리

### 8.2.4 사용자 정의 훅 테스트하기

지금까지 일반적인 컴포넌트에 대해 테스트해봤다면 임의로 만든 사용자 훅을 테스트한다고 가정해보자.
훅을 편리하게 테스트를 하기위해 react-hooks-testing-library의 테스트 방법을 알아보자.

먼저 테스트로 작성할 훅은 useEffectDebugger라는 훅이다.
이 훅은 컴포넌트명과 props를 인수로 받아 해당 컴포넌트가 어떤 props의 변경으로 인해 리렌더링됐는지 확인해주는 일종의 **디버거 역할**을 한다.

이 훅이 구현할 기능은 다음과 같다.

- 최초 컴포넌트 렌더링 시에는 호출하지 않는다.
- 이전 props를 useRef에 저장해 두고, 새로운 props를 넘겨받을 때마다 이전 props와 비교해 무엇이 렌더링을 발생시켰는지 확인한다.
- 이전 props와 신규 props의 비교는 리액트의 원리와 동일하게 Object.is를 활용해 얕은 비교를 수행한다.
- process.env.NODE_ENV === 'production'인 경우에는 로깅을 하지 않는다. 이는 웹팩을 빌드 도구로 사용할 경우 일반적으로 트리쉐이킹이 이뤄지는 일종의 최적화 기법이다. 웹팩을 비롯한 많은 번들러에서는 process.env.NODE_ENV === 'production'인 경우에는 해당 코드가 빌드 결과물에 포함되지 않는다. 이는 운영 환경에서는 해당 코드가 실행되지 않는다는 의미다.

이러한 요구사항을 준수한 useEffectDebugger 훅을 살펴보겠습니다.

```jsx
import { useEffect, useRef, DependencyList } from 'react'

export type Props = Record<string, unknown>

export const CONSOLE_PREFIX = '[useEffectDebugger]'

export default function useEffectDebugger(
  componentName: string,
  props? : Props,
) {
  const preProps = useRef<Props | undefined>()

  useEffect(() => {
    if (process.env.NODE_ENV === 'production') {
      return
    }

    const prevPropsCurrent = prevProps.current

    if (prevPropsCurrent !== undefined) {
      const allKeys = Object.keys({ ...prevProps.current, ...props })

      const changedProps: Props = allKeys.reduce<Props>((result, key) => {
        const prevValue = prevPropsCurrent[key]
        const currentValue = props ? props[key] : undefined

        if (!Object.is(prevValue, currentValue)) {
          result[key] = {
            before: prevValue,
            after: currentValue,
          }
        }

        return result
      }, {})

      if (Object.keys.changedProps.lenght) {
        // eslint-disable-next-line no-console
        console.log(CONSOLE_PREFIX, componentName, changedProps)
      }
    }

    prevProps.current = props
  })
}

```

이 훅은 다음과 같이 사용할 수 있다.

```jsx
import { useState } from "react";

import useEffectDebugger from "./useEffectDebugger";

function Test(props: { a: string, b: number }) {
  const { a, b } = props;
  useEffectDebugger("TestComponent", props);

  return (
    <>
      <div>{a}</div>
      <div>{b}</div>
    </>
  );
}

function App() {
  const [count, setCount] = useState(0);

  return (
    <>
      <button onClick={() => setcount((count) => count + 1)}>up</button>
      <Test a={count % 2 === 0 ? "짝수" : "홀수"} b={count} />
    </>
  );
}

export default App;
```

출력 결과 :

```bash
[useEffectDebugger] TestComponent {"a":{"before":"짝수", "after":"홀수"}, "b":{"before":0,"after":1}}
[useEffectDebugger] TestComponent {"a":{"before":"홀수", "after":"짝수"}, "b":{"before":1,"after":2}}
[useEffectDebugger] TestComponent {"a":{"before":"짝수", "after":"홀수"}, "b":{"before":2,"after":3}}
```

useEffectDebugger는 어디까지나 props가 변경되는 것만 확인할 수 있다는 것을 염두에 둬야한다.
props를 useRef에 저장해 두고, 이후에 새롭게 들어오는 props를 비교해 변경된 값만 console.log로 로깅을 남기고 있다.

하지만 테스트 코드를 통해 확인하는 편이 훨씬 더 확실하고 실수도 줄이는 안전한 방식일 것이다.
useEffectDebugger를 테스트하는 코드를 작성해보자.

### 8.2.5 테스트를 작성하기에 앞서 고려해야 할 점

해당 소프트웨어가 얼마나 테스트됐는지를 나타내는 지표를 **테스트 커버리지**라고 한다.
테스트 커버리지가 높을수록 좋고 꾸준히 테스트 코드를 작성하라는 것이다.
**그러나 테스트 커버리지가 만능은 아니다.**
먼저 테스트 커버리지는 단순히 얼마나 많은 코드가 테스트되고 있는지를 나타내는 지표일 뿐, 테스트가 잘되고 있는지를 나타내는 것은 아니다.

`절대 테스트 커버리지를 맹신해서는 안된다.`

테스트 커버리지를 100%까지 끌어올릴 수 있는 상황은 생각보다 드물다는 것이다.

서버코드와는 다르게 프론트엔드 코드는 사용자의 입력이 매우 자유롭기 때문에 이러한 모든 상황을 커버해 테스트를 작성하기란 불가능하다.

따라서 테스트 코드를 작성하기 전에 생각해 봐야 할 최우선 과제는 **애플리케이션에서 가장 취약하거나 중요한 부분을 파악하는 것**이다

결론은 테스트 코드는 개발자가 단순 코드 작성만으로는 쉽게 이룰 수 없는 목표인 소프트웨어 품질에 대한 확신을 얻기 위해 작성하는 것이다.

### 8.2.6 그 밖에 해볼만한 여러 가지 테스트

사용자가 한정적이고, 사용할 수 있는 케이스도 어느 정도 제한적인 백엔드에 비해 프론트엔드는 무작위 사용자가 애플리케이션에서 갖가지 작업을 할 수 있으므로 이를 테스트하기 위한 여러가지 방법이 있다.

- 유닛 테스트(Unit Test): 각각의 코드나 컴포넌트가 독립적으로 분리된 환경에서 의도된 대로 정확히 작동하는지 검증하는 테스트
- 통합 테스트(Integration Test): 유닛 테스트를 통과한 여러 컴포넌트가 묶여서 하나의 기능으로 정상적으로 작동하는지 확인하는 테스트
- 엔드 투 엔드(End to End Test): 흔히 E2E 테스트라 하며, 실제 사용자처럼 작동하는 로봇을 활용해 애플리케이션의 전체적인 기능을 확인하는 테스트

각 테스트 설명에서도 알 수 있지만 유닛 테스트에서 통합 테스트, 엔드 투 엔드 테스트로 갈수록 테스트가 실패할 지점이 많아지고, 테스트 코드도 복잡해지며, 테스트해야 할 경우의 수도 많아지고, 테스트 자체를 구축하는 것도 어려워진다.

### 8.2.7 정리

## 테스트가 이뤄야 할 목표는 `애플리케이션이 비즈니스 요구사항을 충족하는지 확인하는 것` 한 가지뿐이다.
