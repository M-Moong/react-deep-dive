# 8장 좋은 리액트 코드 작성을 위한 환경 구축하기

- [8장 좋은 리액트 코드 작성을 위한 환경 구축하기](#8장-좋은-리액트-코드-작성을-위한-환경-구축하기)
  - [8.2 리액트 팀이 권장하는 리액트 테스트 라이브러리](#82-리액트-팀이-권장하는-리액트-테스트-라이브러리)
    - [8.2.4 사용자 정의 훅 테스트하기](#824-사용자-정의-훅-테스트하기)
    - [8.2.5 테스트를 작성하기에 앞서 고려해야 할 점](#825-테스트를-작성하기에-앞서-고려해야-할-점)
    - [8.2.6 그 밖에 해볼만한 여러 가지 테스트](#826-그-밖에-해볼만한-여러-가지-테스트)
    - [8.2.7 정리](#827-정리)

## 8.2 리액트 팀이 권장하는 리액트 테스트 라이브러리

### 8.2.4 사용자 정의 훅 테스트하기

지금까지 일반적인 컴포넌트에 대해 테스트해봤다면 임의로 만든 사용자 훅을 테스트한다고 가정해보자.
훅을 편리하게 테스트를 하기위해 react-hooks-testing-library의 테스트 방법을 알아보자.

먼저 테스트로 작성할 훅은 useEffectDebugger라는 훅이다.
이 훅은 컴포넌트명과 props를 인수로 받아 해당 컴포넌트가 어떤 props의 변경으로 인해 리렌더링됐는지 확인해주는 일종의 **디버거 역할**을 한다.

이 훅이 구현할 기능은 다음과 같다.

- 최초 컴포넌트 렌더링 시에는 호출하지 않는다.
- 이전 props를 useRef에 저장해 두고, 새로운 props를 넘겨받을 때마다 이전 props와 비교해 무엇이 렌더링을 발생시켰는지 확인한다.
- 이전 props와 신규 props의 비교는 리액트의 원리와 동일하게 Object.is를 활용해 얕은 비교를 수행한다.
- process.env.NODE_ENV === 'production'인 경우에는 로깅을 하지 않는다. 이는 웹팩을 빌드 도구로 사용할 경우 일반적으로 트리쉐이킹이 이뤄지는 일종의 최적화 기법이다. 웹팩을 비롯한 많은 번들러에서는 process.env.NODE_ENV === 'production'인 경우에는 해당 코드가 빌드 결과물에 포함되지 않는다. 이는 운영 환경에서는 해당 코드가 실행되지 않는다는 의미다.

이 훅의 사용방법을 알아보자.

```jsx
import { useState } from "react";

import useEffectDebugger from "./useEffectDebugger";

function Test(props: { a: string, b: number }) {
  const { a, b } = props;
  useEffectDebugger("TestComponent", props);

  return (
    <>
      <div>{a}</div>
      <div>{b}</div>
    </>
  );
}

function App() {
  const [count, setCount] = useState(0);

  return (
    <>
      <button onClick={() => setcount((count) => count + 1)}>up</button>
      <Test a={count % 2 === 0 ? "짝수" : "홀수"} b={count} />
    </>
  );
}

export default App;
```

출력 결과 :

```bash
[useEffectDebugger] TestComponent {"a":{"before":"짝수", "after":"홀수"}, "b":{"before":0,"after":1}}
[useEffectDebugger] TestComponent {"a":{"before":"홀수", "after":"짝수"}, "b":{"before":1,"after":2}}
[useEffectDebugger] TestComponent {"a":{"before":"짝수", "after":"홀수"}, "b":{"before":2,"after":3}}
```

useEffectDebugger는 어디까지나 props가 변경되는 것만 확인할 수 있다는 것을 염두에 둬야한다.
props를 useRef에 저장해 두고, 이후에 새롭게 들어오는 props를 비교해 변경된 값만 console.log로 로깅을 남기고 있다.

하지만 테스트 코드를 통해 확인하는 편이 훨씬 더 확실하고 실수도 줄이는 안전한 방식일 것이다.
useEffectDebugger를 테스트하는 코드를 작성해보자.

### 8.2.5 테스트를 작성하기에 앞서 고려해야 할 점

### 8.2.6 그 밖에 해볼만한 여러 가지 테스트

### 8.2.7 정리
